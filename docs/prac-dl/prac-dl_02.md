## 第二章：使用 Python**

![image](img/common.jpg)

如果你已经熟悉 Python，可以跳过这一章。本章节是为那些已经熟悉编程，但不熟悉 Python 的读者准备的。我们只会介绍足够的 Python 知识，帮助你理解本书中的代码示例。如果你对计算机编程几乎没有经验，建议你先阅读更为全面的书籍，例如 Eric Matthes 的《Python Crash Course》第二版（No Starch Press, 2019）。

Python 最简单的形式是通过缩进将顺序语句分组为块；包括数字、字符串、元组、列表和字典等数据结构；控制结构，包括`if-elif-else`、for 循环、while 循环、with 语句以及 try-except 块；具有可选嵌套函数的函数；以及一个庞大的可导入模块库。我们将逐一介绍这些特性。

### Python 解释器

在 Linux 系统中，Python 通常有两种使用方式。你可以从命令行运行 Python 解释器并交互式地输入命令，或者运行一个 Python 命令脚本。只需在控制台中输入`python3`即可以交互方式使用 Python：

```py
$ python3

Python 3.6.7 (default, Oct 22 2018, 11:32:17)

[GCC 8.2.0] on linux

Type "help", "copyright", "credits" or "license" for more information.

>>>
```

正如你所看到的，Python 会为你打开一个提示符，你可以在其中输入命令，提示符以`>>>`开始。输入类似`1+2`的表达式并按下`ENTER`键，Python 会立即评估该表达式并返回结果。当你想退出控制台时，使用`CTRL`-D。

### 语句和空白

与几乎所有其他编程语言一样，除非通过控制流结构进行修改，否则 Python 中的语句按出现的顺序依次执行。举个例子，考虑以下代码：

```py
statement1

statement2

statement3
```

在这里，`statement1`会首先执行，然后是`statement2`，最后是`statement3`。

多个语句可以被组合成叫做*块*的单元。例如，当`if`语句的条件为`True`时，可以触发一个块的执行。从语法上讲，与`if`语句相关联的语句需要以某种方式标记，以便计算机知道哪些语句需要执行。经典语言如 Pascal 使用笨重的`BEGIN`和`END`关键字。C 系列语言，包括当前广泛使用的大多数语言，则使用花括号：“{”和“}”。

在 Python 中，我们使用缩进。这使得 Python 代码的阅读变得优雅，因为它遵循传统大纲的格式。它还使代码在不同作者之间更加视觉一致，减少了混淆的空间。在 Python 中，当我们使用`if else`语句时，即使我们尚未完全理解`if`语句的格式，也可以轻松看到哪些语句应当与条件的哪一部分一起执行。例如：

```py
if condition1:

    statement1

    statement2

else:

    statement3
```

缩进清晰地表明，只有当`condition1`（无论是什么）为真时，`statement1`和`statement2`才会被执行。同样，我们看到`statement3`会在`condition1`不为真时执行。

注意前面 `if` 示例中的冒号。Python 使用这些冒号来标记代码块。你必须在任何控制语句后面加上冒号，然后下一行应该始终缩进一级。如果你尝试使用控制结构，但在控制结构的主体中没有任何语句，Python 会抛出一个错误。

例如，`else:` 子句不能在没有至少一个语句的代码块中出现。如果没有 `else` 的需求，就不要包含它。（如果你真的想包含它，可以使用 `pass` 关键字告诉 Python 你知道代码块中需要一个语句，但你真的不希望那个条件执行任何操作。）

缩进可能会让初学 Python 的人感到害怕，但你可以通过正确配置文本编辑器来简化这个过程。Python 的约定是，你应该告诉你的文本编辑器执行以下操作：

1.  用空格代替制表符。像避瘟疫一样避开制表符。

1.  每次按下 TAB 键时，插入四个空格。

1.  按下 ENTER 键时自动缩进。

在这些设置下，当你输入控制语句的“：”时，只需按 ENTER 键，Python 会自动缩进代码块。

配置这些设置的方法取决于使用的文本编辑器，当然，但任何值得一提的文本编辑器都能完成这些操作，许多编辑器默认启用自动缩进。如果你使用集成开发环境（IDE），那么一旦 IDE 识别到你在使用 Python 编写代码，许多这些约定将自动生效。

### 变量和基本数据结构

Python 的原生数据结构简洁优雅。在这一节中，我们将介绍数字表示、变量、字符串、列表和字典。

#### 数字表示

Python 中的数字分为两种类型：整数和浮点数。*整数*是像 42 和 66 这样的整数。*浮点数*是带小数点的数字，例如 3.1415 和 2.718。在本书中我们将忽略复数，尽管 Python 是支持复数的。

如果你不包括小数点，Python 会默认你指的是整数；否则，它会使用浮点数。浮点数也可以使用科学计数法表示，其中 `6.022e23` 意味着 6.023 × 10²³。

大多数编程语言只能表示一定范围内的数字，但 Python 对整数没有这样的限制，整数可以大到只要内存足够存储它们。为了好玩，输入**`2**2001`**并看看会发生什么。计算机存储和操作数字的方式非常有趣。那些好奇的人可能会想进一步探究。^(1)

#### 变量

*变量*提供了一个有用的存储数据的地方以供重用。幸运的是，使用 Python 变量非常简单。Python 是*动态类型*的，这意味着我们不需要提前声明变量将存储的数据类型。我们只需将数据赋值给变量，Python 会自动推断出类型。

我们甚至可以通过赋值一个新值来改变变量存储的数据类型，而不管原来的数据类型是什么。例如，下面的赋值在 Python 中都是有效的：

```py
❶ >>> v = 123

❷ >>> n = 3.141592

❸ >>> v = 6.022e23
```

代码将整数 123 赋值给变量`v` ❶，将浮点值 3.141592 赋值给变量`n` ❷，然后将浮点值重新赋值给`v`：6.022 × 10²³ ❸。

Python 变量名是区分大小写的，必须以字母开头，并且可以包含字母、数字和“_”字符。许多 Python 程序员遵循 Java 的驼峰命名法，在这里也有体现，但这并不是强制要求的：

```py
>>> myVariableName=123
```

#### 字符串

Python 支持使用字符串处理文本数据。你可以用引号标记*字符串*的开始和结束，可以是单引号（’）、双引号（“”）或三引号（’’’），只要开头和结尾使用相同的引号。三引号字符串是特别的：它可以跨越多行文本，通常在定义函数后紧接着使用它来实现简单的文档字符串。以下这些都是有效的 Python 字符串：

```py
>>> thing1 = 'how now brown cow?'

>>> thing2 = "I don't think; therefore I am not."

>>> thing3 = """

one

two

three

"""
```

这里，`thing1`是一个简单的字符串；`thing2`也是一个简单字符串，但注意它包含一个单引号作为撇号。我们能这么做是因为我们使用了双引号来开始这个字符串；如果想在字符串中使用双引号，那么就需要用单引号来包围整个字符串。

最后一个字符串`thing3`跨越了多行。从`one`到`two`之间的换行符也是字符串的一部分，打印时会显示出来。注意，如果你在 Python 解释器中实际输入赋值给`thing3`，你会看到解释器会插入省略号（`...`）。我们在示例中忽略了这些，因为它们可能会造成混淆，实际上也不是字符串的一部分。

#### 列表

字符串和数字是*原始数据类型*，这意味着它们不是由一组数据构成的。可以把它们看作是原子。通过使用元组和列表，它们可以组合成更复杂的数据结构。*列表*是一个有序的其他数据集合，里面可以是原始数据或任何其他数据集合。例如，列表里也可以包含列表。

##### 基本列表操作

与其他一些数据类型不同，添加到列表中的项目顺序是重要的。我们直接通过一些列表示例来跳入讨论，然后再讲解发生了什么：

```py
❶ >>> t = ["Quednoe","Biggles",39]

   >>> t

       ['Quednoe', 'Biggles', 39]

❷ >>> t[0]

      'Quednoe'

  >>> t[1]

      'Biggles'

  >>> t[2]

      39
```

首先，我们定义一个列表 ❶。我们使用“`[`”字符开始列表，输入项目，并用“`]`”字符结束。列表中的项目由逗号（`,`）分隔。这个列表有三个项目，当我们让 Python 评估表达式`t`时，会看到这个列表。

我们可以像处理数组一样，通过使用数字和方括号来索引列表。在这里，我们使用方括号表示法❷来请求列表中的第一个元素。对于第二个和第三个元素，我们也是一样操作。

我们可以通过使用`append`方法向列表添加元素：

```py
>>> t.append(3.14)

>>> t

    ['Quednoe', 'Biggles', 39, 3.14]
```

在这里，我们看到列表`t`现在有了第四个成员`3.14`。请注意，向列表追加元素会将其添加到列表的*末尾*。

让我们看几个使用列表的例子。

```py
❶ >>> t[-1]

       3.14

❷ >>> t[0:2]

       ['Quednoe', 'Biggles']

❸ >>> t[1] = 'Melvin'

   >>> t

       ['Quednoe', 'Melvin', 39, 3.14]

❹ >>> t.index("Melvin")

       1
```

这些例子展示了如何使用负索引❶，负索引从列表的*末尾*开始并向前计数，因此`-1`总是返回列表中的最后一个元素。我们还展示了如何使用范围来选择列表的子集❷。

要使用 Python 的范围，可以遵循`[a:b]`的格式，从索引`a`返回到*小于*`b`的所有元素。在数学上，这就是[*a*, *b*)，其中`b`-th 元素不包括在内。因此，要求`t[0:2]`将只返回元素 0 和 1。请注意，如果你跳过了范围的开始部分或结束部分，它将默认从第一个元素开始（如果跳过了开始部分），或从最后一个元素开始（如果跳过了结束部分）。

如果你在赋值语句的左侧使用索引，则会修改该列表的元素❸。现在我们看到列表的第二个元素已经改变。

最后，我们使用`index`方法来搜索列表中的元素❹。如果找到了该元素，`index`将返回该元素的索引。如果元素不在列表中，Python 会抛出一个错误。

如果你想知道某个元素是否在列表中，但不关心它的位置，可以使用`in`，如下所示：

```py
>>> b = [1,2,3,4]

>>> 2 in b

    True

>>> 5 in b

    False
```

这里返回的值是布尔值`True`和`False`。请注意，`True`和`False`的首字母是大写的。布尔值也可以赋值给变量。我们还应该提到`None`，它是 Python 版本的`NULL`（至少从第一印象来看）。我们将在讨论 Python 函数时介绍`None`的实际应用，详见“函数”章节—在第 39 页。

##### 复制列表

关于列表，最后需要注意的一点是，Python 在将列表赋值给新变量时，并不会复制列表；相反，它将新变量指向列表已存在的内存位置。例如：

```py
>>> a = [0,1,2,3,4]

>>> a

    [0, 1, 2, 3, 4]

>>> b = a

>>> b

     [0, 1, 2, 3, 4]
```

这里我们定义了一个包含五个数字的列表`a`。然后我们将该列表赋值给一个新变量`b`，并且看到`b`确实和`a`相同。

到目前为止，一切正常。然而，如果我们决定像这样更改`a`的某个元素会怎样：

```py
>>> a[2] = 3

>>> a

    [0, 1, 3, 3, 4]

>>> b

    [0, 1, 3, 3, 4]
```

我们看到`a`已经如预期那样更新了，但可能令人惊讶的是，`b`也发生了变化。这是因为将`a`赋值给`b`时，`b`指向了与`a`相同的内存位置，它并没有实际复制`a`的内容。

如果我们想在将`a`赋值给`b`时复制`a`，我们需要显式地选择`a`中的所有元素，如下所示：

```py
❶ >>> b = a[:]

  >>> a

      [0, 1, 3, 3, 4]

  >>> b

      [0, 1, 3, 3, 4]

  >>> a[2] = 2

  >>> a

      [0, 1, 2, 3, 4]

  >>> b

      [0, 1, 3, 3, 4]
```

在这里，我们定义了一个列表`a`，然后通过选择`a`的所有元素❶将`a`赋值给`b`。我们看到`b`现在看起来像`a`。接下来，我们更新`a`中的*第三*项，并看到`a`现在看起来如我们所预期，第三项从`3`变成了`2`。然而，`b`在这种情况下没有被改变，因为最初的赋值通过选择`a`的所有元素创建了一个新的列表在内存中。

Python 不自动复制列表的原因是列表可能非常大，复制它们会浪费大量内存。完全复制由其他嵌套列表构成的列表可能不是一件简单的事情。通过选择所有元素的方法❶只会进行浅拷贝——嵌套元素仍然是别名。如果需要递归地复制包含嵌套元素的所有列表层级，可以使用`copy`模块中的`deepcopy`函数。

Python 有另一种类似于列表的数据类型，叫做*元组*。元组使用圆括号定义，而不是方括号，它们与列表非常相似，除了定义后无法修改。通常，我们会使用列表，但 NumPy 会偶尔使用元组（参见第三章）。

#### 字典

我们要看的最后一种数据类型是*字典*。字典由一组键组成，每个键都与一个值相关联。你可以通过“`{`”和“`}`”字符来定义字典。与列表类似，值可以是任何类型的对象，包括另一个字典。键通常是字符串，但也可以是数字或其他对象。你可以这样定义一个字典：

```py
>>> d = {"a":1, "b":2, "c":3}

>>> d.keys()

    dict_keys(['a', 'b', 'c'])
```

这个示例展示了如何通过直接列出字典的内容来定义字典。字典的元素是按键:值对给出的。在这里，所有的键都是字符串，每个键所关联的值是一个整数。`keys`方法返回字典中的所有键。

上面的语法在字典的内容已经知道的情况下很有用。通常，情况并非如此。大多数时候，字典已经被定义，我们会单独添加元素：

```py
>>> d = {}

>>> d["a"] = 1 

>>> d["b"] = 2

>>> d["c"] = 3
```

在这里，我们定义了一个空字典`d`，并为一组新键单独赋值。如果键已经存在于字典`d`中，则其值会被更新。

要获取与特定键关联的值，只需使用该键索引字典：

```py
>>> d["b"]

    2
```

如果键在字典中不存在，Python 会抛出一个错误。要测试一个键是否在字典中，可以使用`in`，像这样：

```py
>>> "c" in d

    True
```

在列表和字典之间，你可以方便地存储几乎任何数据。这是像 Python 这样的语言的一个好处：程序员可以将精力集中在完成当前任务上，而不必实现复杂的数据结构。列表和字典的使用非常快速，通常情况下，它们是你所需要的，除非你在做科学计算，这时我们会使用 NumPy，如在第三章中讨论的那样。

### 控制结构

Python 实现了几种*控制结构*，允许你使用语法来改变程序流。我们将看看这些：

+   `if`-`elif`-`else`

+   `for` 循环

+   `while` 循环

+   `with`语句

+   `try`-`except`语句块

#### if-elif-else 语句

`if`语句用于做出决策。你给它一个条件，该条件必须返回布尔值`True`或`False`。如果条件为真，第一个代码块将被执行。如果条件为假，什么也不会发生，代码将跳过`if`语句，除非你添加了`else`，此时`else`的代码块将被执行。你还可以通过使用`elif`关键字在一个语句中测试多个条件，它会为每个条件添加自己的代码块。示例如下：

```py
❶ >>> disc = b**2 - 4*a*c

❷ >>> if (disc < 0):

          print("imaginary")

    ❸ elif (disc == 0):

          print("single real")

       else:

         ❹ print("two real")
```

这检查一个二次多项式的判别式，*ax*² + *bx* + *c*，以确定解的数量和类型：实数、两个实数，还是虚数。解是使多项式等于零的*x*值。

首先，代码计算判别式值(`disc`)❶。然后检查该值是否小于零❷。如果是，表示有两个虚数解。如果判别式恰好为零❸，则只有一个解，是实数。最后，如果以上条件都不成立，`else`代码块将执行；在这种情况下，表示有两个实数解❹。条件周围的括号并非必需，但可以提高可读性。另外，请注意，Python 使用“`**`”表示指数运算，因此`b**2-4*a*c` = *b*² *–* 4*ac*。你可以根据需要使用任意多个`elif`语句，也可以不使用，最后可以有一个可选的`else`语句。Python 没有像其他常见编程语言中那样的`case`或`switch`语句。

#### `for`循环

几乎所有结构化编程语言都有循环来重复运行特定的代码块。在本节中，我们将讨论 Python 中的几种类型。

Python 的主要循环结构是`for`循环。在其他编程语言中，通常`for`循环是从某个起始值到结束值的计数循环，循环每次增加一个固定的量。而在 Python 中，循环遍历的是可以被迭代的对象，即具有`next`方法的对象。这包括字符串中的字符、列表或元组中的元素，或者字典中的元素。

Python 有两个内置函数，在循环中非常方便。第一个是`range`，它创建一个生成器对象，按顺序生成整数，默认从`0`开始，除非另行指定：

```py
❶ >>> for i in range(6):

         print(i)

  0

  1

  2

  3

  4

  5
```

`range`函数❶返回值`0...5`，`for`语句将每次把这些值依次赋给`i`，直到循环结束。在这里，我们只是使用 Python 的内置函数`print`打印当前`i`的值。

与`for`循环一起使用的另一个有用的函数是`enumerate`。该函数返回两个值，第一个是当前元素的索引，第二个是该元素本身。一个示例将会更清楚地说明：

```py
>>> x = ["how","now","brown","cow"]

>>> for i in x: ❶

      print(i)

how

now

brown

cow

>>> for i,v in enumerate(x): ❷

      print(i,v)

0 how

1 now

2 brown

3 cow
```

在第一次仅遍历列表 `x` ❶ 时，我们在每次迭代中将 `x` 的每个元素赋值给 `i`。第二个循环使用 `enumerate`，并为每次迭代提供 *两个* 值：当前索引，存储在 `i` 中，以及当前列表 `x` 中的元素，存储在 `v` 中 ❷。Python 能够同时将多个部分赋值给多个变量。在这种情况下，循环体打印出索引，后跟该索引对应的元素。

当我们使用 `for` 循环遍历字典时会发生什么呢？我们来看看：

```py
❶ >>> d = {"a":1, "b":2, "c":2.718}

❷ >>> for i in d:

         print(i)

  a

  b

  c

❸ >>> for i in d:

         print(i, d[i])

  a 1

  b 2

  c 2.718
```

这里我们首先定义了一个字典 `d`，它有三个键 ❶。如果我们简单地遍历字典变量，我们将得到键 ❷。然而，如果我们随后使用键来返回关联的值，如第二个循环 ❸ 所示，我们将遍历整个字典，每个值访问一次。

Python 的一个特别吸引人的特点是我们可以将 `for` 循环与列表结合使用，形成 *列表推导式*。列表推导式开始时是一个以“`[`”为开头的列表，但与列出单独的元素不同，列表的主体实际上是生成列表的代码。这个简写方式需要一点时间来适应，但一旦熟悉了，你会发现它是许多 `for` 循环的高效替代方案。例如：

```py
❶ >>> import random

  >>> a = []

  >>> for i in range(10000):

❷         a.append(random.random())

❸ >>> b = [random.random() for i in range(10000)]

❹ >>> m3 = [i for i in range(10000) if (i % 3) == 0]
```

我们首先导入标准的随机数库 ❶，然后用 10,000 个在区间 [0,1) 内的随机数填充列表 `a`（表示 0 包含，1 不包含）❷。接下来，我们也用列表推导式将 `b` 填充为 10,000 个随机数 ❸。请注意，语法与我们定义带有值的列表时相同，但这里列表的主体是一个 *返回* 值的表达式。在这种情况下，它是调用 `random.random()` 和一个遍历 10,000 个元素的 `for` 循环。

最后的例子创建了一个列表 `m3`，包含所有小于 10,000 的 3 的倍数，包括 0 ❹。`if` 子句是决定特定 `i` 值是否在列表中的测试条件。百分号运算符是 *取模* 运算符，返回除法后的余数。在这里，它是判断将 `i` 除以 3 后的余数是否为零。如果余数为零，则说明 `i` 是 3 的倍数（或 0）。

#### while 循环

许多编程语言包括顶端测试和底端测试的循环。*顶端测试循环* 会在执行循环体之前测试循环条件，如果条件不成立，则循环体永远不会执行。*底端测试循环* 会至少执行一次循环体，然后才测试是否需要再次执行循环。C 语言中的 `while` 循环是顶端测试循环，而 `do...while` 循环是底端测试循环。Python 只有顶端测试的 `while` 循环，语法如下：

```py
❶ >>> i = 0

❷ >>> while (i < 4):

        print(i)

      ❸ i += 1

  0

  1

  2

  3
```

我们必须在开始循环之前初始化循环控制变量（`i`）为 0 ❶，以确保条件 `i < 4` 一开始为真 ❷。还要注意，我们在循环体的末尾显式地增加 `i` ❸。表达式 `i += 1` 是 `i = i + 1` 的简写，表示 `i` 增加 1。Python 不支持 C 风格的递增和递减操作，比如 `i ++`。如果你尝试使用，Python 会友好地提示你 `SyntaxError`。

`while` 循环只要条件评估为 `True` 就会一直重复。程序员需要在循环体中做些事情，使条件最终为 `False`，从而结束循环。你还可以手动退出循环，正如你将在下一部分看到的那样。

#### `break` 和 `continue` 语句

`for` 和 `while` 循环与另外两个 Python 语句配合使用：要立即退出循环，使用 `break` 语句；要立即跳到下一个迭代，使用 `continue`。`break` 的一个常见用法是跳出无限循环：

```py
>>> i = 0

>>> while True:

        print(i)

        i += 1

        if (i == 4):

         ❶ break

0

1

2

3
```

这与之前的 `while` 循环示例产生相同的输出，但是当满足终止条件时，通过 `break` 显式地退出循环 ❶；在这里，就是当 `i` 增加到 4 时。对于这个示例，使用 `break` 并没有太大意义，因为有其他更清晰的方法来实现这一点，但通常情况下，循环可能需要一直执行直到程序结束，或者直到某些罕见的情况或错误发生。例如，命令行解释器会不断检查键盘输入。每当一个字符输入时，它会被添加到缓冲区中。然而，如果字符是“换行符”，则会跳出循环并解释缓冲区的内容。

`continue` 语句会跳过循环体中 `continue` 后的所有语句，直接进入下一个迭代。例如：

```py
>>> for i in range(4):

        print(i)

     ❶ continue

        print("xyzzy")

0

1

2

3
```

这里，`continue` ❶ 确保了第二个 `print` 语句永远不会被执行。

#### `with` 语句

Python 的 `with` 语句在处理文件时非常有用。例如，下面的代码使用 `with` 语句打开一个磁盘上的文件，并将其内容读取到一个字符串中：

```py
>>> with open("sesame") as f:

        s = f.read()

>>> s

'this is a file\n'
```

`with` 语句打开一个名为 *sesame* 的文件，并将文件对象赋值给 `f`。然后我们使用 `read` 方法读取整个文件内容作为字符串，并将其赋值给 `s`。评估 `s` 后我们看到文件包含字符串“this is a file”，并且末尾有一个换行符。

请注意，上面的示例使用了 `open` 和 `read`，但是在完成后没有显式关闭文件。这是因为当 `with` 语句退出时，`close` 方法会自动调用，因为 `f` 离开作用域（这意味着 `f` 只在 `with` 语句体内定义）。

#### 处理错误的 `try-except` 语句块

最后，让我们快速了解 Python 捕获和处理错误的能力，而不是让错误停止我们的程序。我们将简单地了解 Python 错误控制的一个框架，以便调试。

为了捕获错误而不是让它停止程序执行，我们可以用`try...except`块将可能引发错误的语句进行封装。如果在`try`之后、`except`之前的任何语句引发了错误，它将被捕获，执行将转到`except`块中的语句。这里的示例展示了如何捕获`try`块中包含的语句中发生的*任何*错误；不过，值得注意的是，Python 提供了丰富的错误类型，用户也可以自定义错误类型：

```py
>>> x = 1.0/0.0

Traceback (most recent call last):

  File "<stdin>", line 1, in <module>

ZeroDivisionError: float division by zero

>>> try:

        x = 1.0/0.0

    except:

        x = 0

>>> x

0
```

在这里，我们首先尝试将除以零的结果赋值给`x`。这会失败，并显示来自 Python 的错误信息。然而，如果我们将赋值操作放入`try`块中，Python 会跳转到`except`块中的`x = 0`行，并将`x = 0`赋值，如示所示。

如果你没有使用支持代码执行中断的高级 Python 编程环境，下面的结构会很有用，因为它在遇到时会停止执行。这里它在除零错误发生后立即停止执行：

```py
>>> try:

        x = 1.0/0.0

    except:

        import pdb; pdb.set_trace()
```

当发生错误时，如果`pdb`模块尚未导入，它将被导入，并调用`set_trace`函数进入调试环境。当然，`pdb.set_trace()`可以在代码中的任何地方调用——它不一定要在`try...except`块内。

### 函数

在 Python 中，你使用`def`关键字来定义一个函数，后面跟着函数名和括号内的参数列表。即使你不包含任何参数，也必须包括一对括号。由于 Python 是动态类型语言，你只列出函数的参数，而没有类型信息。必要时，你还可以为参数提供默认值。同样，我们这里忽略了 Python 的面向对象能力，仅关注函数的一小部分功能。让我们定义一个简单的函数：

```py
 >>> def product(a,b):

      return a*b

 >>> product(4,5)

    20
```

这个函数被称为`product`，它接受两个参数，我们将在函数中将它们称为`a`和`b`。该函数的主体由一个语句组成——一个`return`语句，它将返回到调用`product`时的代码位置，并返回给定的值，这里是两个参数的乘积。如果我们测试这个函数，就会发现它确实会将两个参数相乘。

接下来，让我们重新定义`product`函数，并为第二个参数提供一个默认值，代码如下：

```py
>>> def product(a,b=3):

        return a*b

>>> product(4,5)

    20

>>> product(3)

    9
```

我们在函数的参数列表中提供了默认值。如果我们使用两个参数，Python 会像之前一样将第二个参数的值赋给函数内部的参数。然而，如果我们没有提供第二个参数，Python 将使用给定的默认值 3，从而返回有意义的结果 3 × 3 = 9。为函数参数提供默认值使其成为关键字参数，正如我们上面所见，我们在调用函数时不需要为该参数提供值。这种技术特别方便，我们在代码示例中时常会用到。

我们下面的最终示例展示了如何定义一个不接受任何参数的函数：

```py
>>> def pp():

      print("plugh")

>>> pp()

    plugh
```

函数`pp`的参数列表为空。函数体中的唯一语句打印出单词*plugh*。该函数没有返回值。

Python 允许你嵌套定义函数，这样一个函数内部就可以定义其他函数。内部函数仅对外部函数可访问。通常不需要这样做，如果你经常这么做，可能需要考虑重构为面向对象设计；不过在某些情况下，这样做是有意义的，所以我们在这里提一下。

最后，一个有用的做法是将默认值设置为`None`，这样我们可以在函数内部检查是否提供了该值，通过测试参数是否为`None`来判断。任何类型的数据变量都可以与`None`进行比较测试。

### 模块

我们通过快速回顾 Python 来结束本部分，接着了解模块系统。这类似于 C 标准库，它为 Python 提供了丰富的开箱即用工具，所有工具都定义为模块。当然，用户也可以创建自己的模块。那么，*模块*就是一组可以导入到程序中的函数。你也可以只从特定模块导入特定的函数到你的程序中，而不是导入整个模块，但前提是你要意识到导入的函数可能与另一个命名空间中的函数同名。

在*命名空间*中，我们指的是一组函数，类似于一个家庭，其中函数是家庭成员的名字。我们程序中所知道的所有函数都在我们的命名空间中。如果我们从一个模块导入函数，这个函数现在也在我们的命名空间中。如果我们导入整个模块，并通过模块名前缀来引用函数，那么我们可以使用这个函数，但它不在我们的命名空间中。我们很快会看到为什么这个区别很重要。

让我们通过一些示例来看看如何使用 Python 库的模块：

```py
>>> import time

>>> time.time()

    1524693601.402852
```

我们首先导入`time`模块。这意味着我们现在可以访问`time`模块中的所有函数，只要我们在函数名前加上`time.`前缀即可。`time`模块中的`time`函数返回自 1970 年 1 月 1 日以来的秒数，这个值被称为*纪元时间*，它对于计算代码执行所需时间非常有用。因为返回的值只会增加，所以从代码开始到结束的纪元时间差值可以表示代码执行的时长。

让我们来看另一个例子：

```py
>>> from time import ctime, localtime

>>> ctime()

    'Wed Apr 25 16:00:21 2020'

>>> localtime().tm_year

    2018
```

在这里，我们没有导入整个`time`模块，而是仅导入了其中的两个函数。这样做将这些函数放入我们的命名空间中，以便我们可以直接调用它们。`ctime`函数返回一个字符串，显示当前的日期和时间，而`localtime`函数则返回当前时间按日期和时间部分拆分后的各部分。这里我们显示了写作时的年份。

我们的最后一个例子展示了为什么通常最好直接导入模块，而不是从中导入函数：

```py
>>> def sqrt(x):

      return 4

>>> sqrt(2)

    4

>>> from math import *

>>> sqrt(2)

    1.4142135623730951
```

首先，我们定义了一个名为`sqrt`的函数。无论传入什么参数，这个函数总是返回 4。当然，这并不是特别有用，但它仍然是一个有效的 Python 函数。

接下来，让我们导入整个`math`库的函数。这个语法将模块中的所有函数放入我们的命名空间，这样我们就可以在不使用模块名的情况下直接引用它们。导入后，我们看到`sqrt`现在返回实际的平方根。

我们的`sqrt`函数实现出了问题吗？当我们导入整个`math`库时，它被覆盖了，因为`math`库中也有一个名为`sqrt`的函数，而由于`math`库在我们的`sqrt`定义之后被导入，因此`math`库中的`sqrt`函数优先被调用。

Python 的模块库是该语言在实用性方面的一个关键优势。标准库有详尽的文档。要快速查看可用的 Python 3.*X*模块列表，请访问*[`docs.python.org/3/py-modindex.html`](https://docs.python.org/3/py-modindex.html)*。Python 的官方网站是：[`www.python.org/`](http://www.python.org/)。我强烈建议你花一些时间浏览这些链接，真正了解 Python 所提供的所有功能。

### 总结

在本章中，我们回顾了 Python 的基础知识，以便为我们理解本书余下部分的代码示例打下基础。我们学习了 Python 的语法和语句，还检查了 Python 的变量和数据结构，接着探索了 Python 的控制结构和函数，最后了解了 Python 的模块库。

在下一章中，我们将深入探讨 NumPy，看看如何让 Python 对我们更加有用。NumPy 是几乎所有机器学习库中使用的核心工具之一，包括本书中我们将使用的库。

1. 参见罗纳德·T·克内塞尔（Ronald T. Kneusel）所著的《*数字与计算机*》（Springer-Verlag，2017 年）。
