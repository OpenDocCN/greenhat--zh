## 第十章：分析时间序列数据

![](img/chapterart.png)

*时间序列数据*，或称为*时间戳数据*，是一组按时间顺序排列的数据点。常见的例子包括经济指数、天气记录和患者健康指标，所有这些都是随着时间的推移而收集的。本章介绍了使用 pandas 库分析时间序列数据并从中提取有意义统计信息的技术。我们将重点分析股市数据，但这些技术也可以应用于各种时间序列数据。

## 规律与不规律时间序列

时间序列可以为任何随时间变化的变量创建，这些变化可以在规律或不规律的时间间隔内记录。规律时间间隔更为常见。例如在金融领域，通常使用时间序列来跟踪股票价格从一天到下一天的变化，正如这里所示：

```py
Date         Closing Price
-----------  -------------
16-FEB-2022  10.26
17-FEB-2022  10.34
18-FEB-2022  10.99
```

如你所见，这个时间序列中的`Date`列包含了按时间顺序排列的一系列时间戳，代表连续几天的事件。相应的数据点，通常被称为*观测值*，展示在`Closing Price`列中。这类时间序列被称为*规律*或*连续*的，因为观测值是连续地在规律的时间间隔内收集的。

另一个规律时间序列的例子是记录一个车辆的经纬度坐标，每分钟记录一次，如下所示：

```py
Time      Coordinates
-------   ----------------
20:43:00  37.801618, -122.374308
20:44:00  37.796599, -122.379432
20:45:00  37.788443, -122.388526
```

在这里，时间戳是时间而不是日期，但它们依然按时间顺序进行，逐分钟记录。

与规律时间序列不同，*不规则时间序列*用于记录事件发生或计划发生的顺序，而不是在规律的时间间隔内。以一个简单的例子为例，考虑一个会议的议程：

```py
Time      Event
-------   ----------------
8:00 AM   Registration
9:00 AM   Morning Sessions
12:10 PM  Lunch
12:30 PM  Afternoon Sessions
```

这个数据点序列的时间戳是不规则分布的，基于每个事件预计需要的时间。

不规则时间序列通常用于数据不可预测的应用中。对于软件开发人员来说，一个典型的不规则时间序列是记录在运行服务器或执行应用程序时遇到的错误日志。很难预测这些错误何时发生，而且它们几乎肯定不会按规律的时间间隔发生。再举一个例子，一个跟踪电力消耗的应用程序可能会使用不规则时间序列来记录随机发生的异常，如突发和故障。

规律和不规律时间序列的共同点在于它们的数据点都是按时间顺序排列的。实际上，时间序列分析正是基于这一关键特性。严格的时间顺序使你能够始终如一地比较时间序列中的事件或数值，从而识别关键统计信息和趋势。

以股票数据为例，时间顺序让你能够跟踪股票的表现。对于逐分钟的车辆地理坐标数据，你可能会使用相邻的坐标对来计算每分钟行驶的距离，然后用这个距离来比较车辆在相邻两分钟之间的平均速度。同时，会议议程的时间顺序让你能够立即看到每个事件的预计持续时间。

在某些情况下，时间戳本身可能并不需要用于分析时间序列；重要的是确保序列中的记录按时间顺序排列。考虑以下不规则时间序列，它包含你在尝试使用错误密码连接到 MySQL 数据库时，脚本可能返回的两个连续错误信息：

```py
_mysql_connector.MySQLInterfaceError: Access denied for user
'root'@'localhost' (using password: YES)
NameError: name 'cursor' is not defined
```

第二个错误信息告诉你名为`cursor`的变量尚未定义。然而，只有查看前面的错误信息，你才能理解问题的根源：由于密码错误，无法与数据库建立连接，因此无法创建`cursor`对象。

分析一系列错误信息是程序员常见的任务，但通常是手动完成的，且没有任何编码。在本章的其余部分，我们将重点讨论带有数值数据点的时间序列，因为这些数据可以通过 Python 脚本轻松分析。特别是，我们将讨论如何从包含股市数据的常规时间序列中提取有意义的信息。

## 常见的时间序列分析技巧

假设你想分析某只股票在一段时间内的每日收盘价时间序列。在这一节中，你将学习一些常见的分析技巧，但首先你需要一些股票数据。

如你在第三章和第五章中所见，你可以通过 Python 脚本使用 yfinance 库获取股市数据。例如，在这里你收集了过去五个交易日的 TSLA（特斯拉公司）股票数据：

```py
import yfinance as yf
ticker = 'TSLA'
tkr = yf.Ticker(ticker)
df = tkr.history(period='5d')
```

结果以 pandas DataFrame 形式呈现，类似于以下内容（你的日期和返回的数据会有所不同）：

```py
 Open     High      Low    Close    Volume  Dividends  Stock Splits
Date
2022-01-10  1000.00  1059.09   980.00  1058.11  30605000          0             0
2022-01-11  1053.67  1075.84  1038.81  1064.40  22021100          0             0
2022-01-12  1078.84  1114.83  1072.58  1106.21  27913000          0             0
2022-01-13  1109.06  1115.59  1026.54  1031.56  32403300          0             0
2022-01-14  1019.88  1052.00  1013.38  1049.60  24246600          0             0
```

如你所见，DataFrame 以日期为索引，这意味着数据是一个正确的、按时间顺序排列的时间序列。这里有开盘价、收盘价以及当天的最高价和最低价列。同时，`Volume` 列显示当天交易的总股数，最右边的两列提供了公司向股东发放的股息和分拆的详细信息。

你可能不需要所有这些列来进行分析。事实上，现在你只需要`Close`这一列。在这里，你将其打印为 pandas Series：

```py
print(df['Close'])
```

该 Series 将类似于以下内容：

```py
Date
2022-01-10    1058.11
2022-01-11    1064.40
2022-01-12    1106.21
2022-01-13    1031.56
2022-01-14    1049.60
```

现在，你准备开始时间序列分析了。我们将重点关注两种常见技术：计算随时间变化的百分比变化，以及在滚动时间窗口内进行汇总计算。你将看到这些技术如何相互配合，揭示数据中的趋势。

### 计算百分比变化

最典型的时间序列分析技术之一是跟踪观察数据随时间的变化。在股票市场数据的情况下，这可能涉及计算某个时间间隔内股票价值的百分比变化。通过这种方式，你可以量化股票的表现，并制定短期投资策略。

从技术角度讲，百分比变化是两个不同时间点的值之间的差异（以百分比表示）。因此，要计算这样的变化，你需要能够将数据点在时间上进行偏移。也就是说，你将较旧的数据点向前移动，使其与较新的数据点对齐；然后你可以比较这些数据点并计算百分比变化。

当时间序列作为 pandas Series 或 DataFrame 实现时，你可以使用`shift()`方法将数据点按所需的时间周期进行偏移。以我们的 TSLA 股票为例，你可能想知道股票的收盘价在两天期间内发生了多少变化。在这种情况下，你可以使用`shift(2)`方法将两天前的收盘价与某一天的收盘价对齐。为了更好地理解偏移的工作原理，你可以将`Close`列向前偏移两天，将结果保存为`2DaysShift`，然后将其与原始的`Close`列连接起来：

```py
print(pd.concat([df['Close'], df['Close'].shift(2)], axis=1, keys= ['Close', '2DaysShift']))
```

输出结果应该类似于以下内容：

```py
 Close  2DaysShift
Date
2022-01-10  1058.11        NaN
2022-01-11  1064.40        NaN
2022-01-12  1106.21    1058.11
2022-01-13  1031.56    1064.40
2022-01-14  1049.60    1106.21
```

正如你所见，`Close`列中的值在`2DaysShift`列中有对应的反映，但偏移了两天。`2DaysShift`中的前两个值为`NaN`，因为在时间序列的前两天没有两天前的股价数据。

要计算某一天的股价与两天前的股价之间的百分比变化，你可以计算当天的股价与两天前股价的差值，并将其除以两天前的股价：

```py
(df['Close'] - df['Close'].shift(2))/ df['Close'].shift(2)
```

然而，在财务分析中，通常的做法是将新值除以旧值，然后对结果取自然对数。当变化在+/- 5%范围内时，这种计算方法几乎能精确地近似百分比变化，且在+/- 20%的范围内仍然非常接近。这里，你使用自然对数计算两天的百分比差异，并将结果存储为`2daysRise`这一新的列，添加到`df`数据框中：

```py
import numpy as np
df['2daysRise'] = np.log(df['Close'] / df['Close'].shift(2))
```

你获取当天的收盘价，并将其除以两天前的收盘价，使用`shift(2)`方法访问。然后，你可以使用 NumPy 的`log()`函数对结果取自然对数。现在，你可以打印`Close`列和`2daysRise`列的内容：

```py
print(df[['Close','2daysRise']])
```

输出的时间序列将类似于以下内容：

```py
 Close   2daysRise
Date
2022-01-10  1058.11        NaN
2022-01-11  1064.40        NaN
2022-01-12  1106.21   0.044455
2022-01-13  1031.56  -0.031339
2022-01-14  1049.60  -0.052530
```

`2daysRise` 列显示与两天前相比的股票涨幅百分比。再次强调，列中的前两个值是 `NaN`，因为在时间序列的前两天没有两天前的价格数据。

### 滚动窗口计算

另一种常见的时间序列分析技术是将每个值与过去 *n* 个周期的平均值进行比较。这被称为 *滚动窗口计算*：你创建一个固定大小的时间窗口，并在时间窗口内的值上执行聚合计算，随着时间窗口在时间序列中“滚动”或*滑动*。以股票数据为例，你可以使用滚动窗口计算来找出前两天的平均收盘价，然后将当前日期的收盘价与该平均值进行比较。这将帮助你了解股票价格随时间的稳定性。

每个 pandas 对象都有一个 `rolling()` 方法，用于查看值的滚动窗口。在这里，你将其与 `shift()` 和 `mean()` 结合使用，以查找前两天的特斯拉股票价格平均值：

```py
df['2daysAvg'] = df['Close'].shift(1).rolling(2).mean()
print(df[['Close', '2daysAvg']])
```

在第一行中，你使用 `shift(1)` 将数据点在时间序列中平移一天。这样做是因为你希望在计算平均值时排除当前日期的价格，这样就可以与它进行比较。接下来，使用 `rolling(2)` 来形成滚动窗口，表示在进行计算时希望参考连续的两行数据。最后，调用 `mean()` 方法来计算每对连续行的平均值。你将结果存储在一个名为 `2daysAvg` 的新列中，并与 `Close` 列一起打印出来。结果的 DataFrame 看起来类似于下面的样子：

```py
 Close  2daysAvg
Date
2022-01-10  1058.11      NaN
2022-01-11  1064.40      NaN
2022-01-12  1106.21  1061.26
2022-01-13  1031.56  1085.30
2022-01-14  1049.60  1068.89
```

`2daysAvg` 列中的价格是前两天的平均值。例如，`2022-01-12` 的值是 `2022-01-10` 和 `2022-01-11` 价格的平均值。

### 计算滚动平均的百分比变化

给定前两天的收盘价滚动平均，下一步逻辑是计算每一天的价格与其相关联的滚动平均之间的百分比变化。在这里，你执行了该计算，再次使用自然对数来近似百分比变化：

```py
df['2daysAvgRise'] = np.log(df['Close'] / df['2daysAvg'])
print(df[['Close','2daysRise','2daysAvgRise']])
```

你将结果存储在一个名为 `2daysAvgRise` 的新列中。然后你将 `Close`、`2daysRise` 和 `2daysAvgRise` 列一起打印出来。输出将类似于下面的样子：

```py
 Close  2daysRise  2daysAvgRise
Date
2022-01-10  1058.11        NaN          NaN
2022-01-11  1064.40        NaN          NaN
2022-01-12  1106.21   0.044455     0.041492
2022-01-13  1031.56  -0.031339    -0.050793
2022-01-14  1049.60  -0.052530    -0.018202
```

对于这个特定的时间序列，两个新创建的指标，`2daysRise` 和 `2daysAvgRise`，都显示了负值和正值。这表明股票的收盘价在观察期内波动较大。当然，你自己的结果可能会显示不同的趋势。

## 多变量时间序列

*多变量时间序列*是指在时间轴上有多个变化变量的时间序列。例如，当你第一次通过 yfinance 库获取特斯拉的股票数据时，它就是一个多变量时间序列，因为它不仅包括股票的收盘价，还包括开盘价、最高价、最低价以及每天的其他数据点。在这种情况下，多变量时间序列追踪的是同一对象——一只股票的多个特征。其他的多变量时间序列可能追踪的是不同对象的相同特征，比如在相同时间段内收集的多只股票的收盘价。

在下面的脚本中，你创建了第二种类型的多变量时间序列，获取了多个股票代码的五天股价数据：

```py
import pandas as pd
import yfinance as yf
❶ stocks = pd.DataFrame()
❷ tickers = ['MSFT','TSLA','GM','AAPL','ORCL','AMZN']
❸ for ticker in tickers:
  tkr = yf.Ticker(ticker)
  hist = tkr.history(period='5d')
❹ hist = pd.DataFrame(hist[['Close']].rename(columns={'Close': ticker}))
❺ if stocks.empty:
  ❻ stocks = hist
  else:
  ❼ stocks = stocks.join(hist)
```

你首先定义`stocks`数据框❶，在其中累积多个股票代码的收盘价。然后你定义一个股票代码列表❷，并遍历该列表❸，使用 yfinance 库获取每个股票代码的最后五天数据。在循环内，你将 yfinance 返回的`hist`数据框缩减为一个单列数据框，其中包含给定股票的收盘价，并将相应的时间戳作为索引❹。然后你检查`stocks`数据框是否为空❺。如果为空，说明这是你第一次进入循环，因此你用`hist`数据框初始化`stocks`数据框❻。在后续的循环中，`stocks`将不为空，因此你将当前的`hist`数据框与`stocks`数据框连接，将另一个股票的收盘价添加到数据集中❼。需要使用`if/else`结构，因为你不能在空的数据框上执行连接操作。

生成的`stocks`数据框将类似于以下内容：

```py
 MSFT    TSLA     GM    AAPL   ORCL     AMZN
Date
2022-01-10  314.26  1058.11  61.07  172.19  89.27  3229.71
2022-01-11  314.98  1064.40  61.45  175.08  88.48  3307.23
2022-01-12  318.26  1106.21  61.02  175.52  88.30  3304.13
2022-01-13  304.79  1031.56  61.77  172.19  87.79  3224.28
2022-01-14  310.20  1049.60  61.09  173.07  87.69  3242.76
```

你拥有一个多变量时间序列，不同的列显示了不同股票的收盘价，所有数据都覆盖相同的时间跨度。

### 处理多变量时间序列

处理多变量时间序列类似于处理单变量时间序列，不同之处在于你需要处理每一行中的多个变量。因此，你的计算通常是在一个循环中进行，遍历序列中的各个列。例如，假设你想过滤`stocks`数据框，剔除那些股票价格在给定时间段内至少有一天比前一天的价格下降超过某个阈值（比如 3%）的股票。在这里，你遍历各列，分析每个股票的数据，决定哪些股票应该保留在数据框中：

```py
❶ stocks_to_keep = []
❷ for i in stocks.columns:
  if stocks[stocks[i]/stocks[i].shift(1)< .97].empty:
    stocks_to_keep.append(i)
print(stocks_to_keep)
```

首先，你创建一个列表来累积你想保留的列名 ❶。然后，你遍历 `stocks` 数据框的列 ❷，判断每列是否包含任何低于前一行数值 3% 的值。具体而言，你使用 `[]` 运算符来筛选数据框，并使用 `shift()` 方法将每一天的收盘价与前一天的收盘价进行比较。如果某列没有包含任何满足筛选条件的值（即如果该列为空），你就将列名添加到 `stocks_to_keep` 列表中。

根据之前显示的 `stocks` 数据框，最终的 `stocks_to_keep` 列表将如下所示：

```py
['GM', 'AAPL', 'ORCL', 'AMZN']
```

正如你所看到的，TSLA 和 MSFT 不在列表中，因为它们包含一个或多个值，跌幅超过了前一天收盘价的 3%。当然，你自己的结果可能会有所不同；你可能会得到一个空列表，或者包含所有股票代码的列表。在这种情况下，可以尝试调整筛选阈值。如果列表为空，尝试将阈值从 0.97 降到 0.96 或更低。相反，如果列表包含所有股票代码，尝试增加阈值。

这里你打印 `stocks` 数据框，使其仅包含 `stocks_to_keep` 列表中的列：

```py
print(stocks[stocks_to_keep])
```

在我的情况下，输出如下所示：

```py
 GM    AAPL   ORCL    AMZN
Date
2022-01-10  61.07  172.19  89.27  3229.71
2022-01-11  61.45  175.08  88.48  3307.23
2022-01-12  61.02  175.52  88.30  3304.13
2022-01-13  61.77  172.19  87.79  3224.28
2022-01-14  61.09  173.07  87.69  3242.76
```

正如预期的那样，`TSLA` 和 `MSFT` 列已经被筛选掉，因为它们包含一个或多个超过 3% 波动阈值的值。

### 分析变量之间的依赖关系

在分析多变量时间序列时，一个常见的任务是识别数据集中不同变量之间的关系。这些关系可能存在也可能不存在。例如，股票的开盘价和收盘价之间可能有一定程度的依赖关系，因为在一天的交易中，收盘价通常不会与开盘价相差超过几个百分点。另一方面，可能在不同行业的两只股票的收盘价之间并不存在依赖关系。

在本节中，我们将介绍一些验证时间序列变量之间关系的技巧。为了演示，我们将检查股票价格的变化与销售量之间是否存在依赖关系。首先，运行以下脚本以获取一个月的股票数据用于分析：

```py
import yfinance as yf
import numpy as np
ticker = 'TSLA'
tkr = yf.Ticker(ticker)
df = tkr.history(period='1mo')
```

正如你已经看到的，yfinance 生成了一个多变量时间序列，其形式为具有多列的 DataFrame。为了这个示例，你只需要其中的两列：`Close` 和 `Volume`。在这里，你根据需要缩减数据框，并将 `Close` 列的名称更改为 `Price`：

```py
df = df[['Close','Volume']].rename(columns={'Close': 'Price'})
```

为了确定`Price`和`Volume`列之间是否存在关系，你应该计算每列从一天到下一天的百分比变化。在这里，你使用`shift(1)`和 NumPy 的`log()`函数来计算`Price`列的每日百分比变化，如之前所述，并将结果存储在新的`priceRise`列中：

```py
df['priceRise'] = np.log(df['Price'] / df['Price'].shift(1))
```

你使用相同的方法来创建一个`volumeRise`列，显示与前一天相比的交易量百分比变化：

```py
df['volumeRise'] = np.log(df['Volume'] / df['Volume'].shift(1))
```

如前所述，自然对数可以在+/-20%的范围内提供接近百分比变化的近似值。虽然`volumeRise`列中的某些值可能超出了这一范围，但你仍然可以在这里使用`log()`，因为在这个示例中不要求非常高的精度；股市分析通常更侧重于预测趋势，而不是找到准确的数值。

如果你现在打印`df`数据框，它大致会是这样：

```py
 Price    Volume  priceRise  volumeRise
Date
2021-12-15   975.98  25056400        NaN         NaN
2021-12-16   926.91  27590500  -0.051585    0.096342
2021-12-17   932.57  33479100   0.006077    0.193450
2021-12-20   899.94  18826700  -0.035616   -0.575645
2021-12-21   938.53  23839300   0.041987    0.236059
2021-12-22  1008.86  31211400   0.072271    0.269448
2021-12-23  1067.00  30904400   0.056020   -0.009885
2021-12-27  1093.93  23715300   0.024935   -0.264778
2021-12-28  1088.46  20108000  -0.005013   -0.165003
2021-12-29  1086.18  18718000  -0.002097   -0.071632
2021-12-30  1070.33  15680300  -0.014700   -0.177080
2021-12-31  1056.78  13528700  -0.012750   -0.147592
2022-01-03  1199.78  34643800   0.126912    0.940305
2022-01-04  1149.58  33416100  -0.042733   -0.036081
2022-01-05  1088.11  26706600  -0.054954   -0.224127
2022-01-06  1064.69  30112200  -0.021758    0.120020
2022-01-07  1026.95  27919000  -0.036090   -0.075623
2022-01-10  1058.11  30605000   0.029891    0.091856
2022-01-11  1064.40  22021100   0.005918   -0.329162
2022-01-12  1106.21  27913000   0.038537    0.237091
2022-01-13  1031.56  32403300  -0.069876    0.149168
2022-01-14  1049.60  24246600   0.017346   -0.289984
```

如果价格和交易量之间存在依赖关系，你会预期价格的高波动（即增加的波动性）会与交易量的高变化相关。为了检查这种情况，你应该为`priceRise`列设定一个阈值，并只查看那些价格变化超过该阈值的行。例如，查看此输出中特定的`priceRise`列的值时，你可能会选择 5%的阈值。另一个数据集可能会建议 3%或 7%的阈值。关键是，只有少数记录应该超过阈值，因此一般来说，股票波动性越大，阈值应该越高。

在这里，你只打印出那些`priceRise`超过阈值的行：

```py
print(df[abs(df['priceRise']) > .05])
```

你使用`abs()`函数来获取百分比变化的绝对值，这样，举例来说，`0.06`和`-0.06`都能满足此处指定的条件。根据之前显示的示例数据，你最终得到如下结果：

```py
 Price    Volume  priceRise  volumeRise
Date
2021-12-16   926.91  27590500  -0.051585    0.096342
2021-12-22  1008.86  31211400   0.072271    0.269448
2021-12-23  1067.00  30904400   0.056020   -0.009885
2022-01-03  1199.78  34643800   0.126912    0.940305
2022-01-05  1088.11  26706600  -0.054954   -0.224127
2022-01-13  1031.56  32403300  -0.069876    0.149168
```

接下来，你计算整个系列的平均交易量变化：

```py
print(df['volumeRise'].mean().round(4))
```

对于这个特定的系列，结果如下：

```py
-0.0016
```

最后，你计算仅针对那些价格变化超出平均水平的行的平均交易量变化。如果结果大于整个系列的平均交易量变化，你就可以知道波动性增加和交易量增加之间存在关系：

```py
print(df[abs(df['priceRise']) > .05]['volumeRise'].mean().round(4))
```

这是你在此系列中获得的内容：

```py
0.2035
```

如你所见，在过滤后的系列中计算的平均交易量变化要远高于整个系列的平均交易量变化。这表明价格波动性和销售量波动性之间可能存在正相关关系。

## 总结

正如你在本章中所学到的，时间序列是一种按时间顺序组织的数据集，其中一个或多个变量随时间变化。以股市数据为例，你了解了一些使用 pandas 分析时间序列数据的技术，以便从中得出有用的统计信息。你学会了如何在时间序列中移动数据点，以便计算随时间的变化。你还学会了执行滚动窗口计算，或在固定时间间隔内进行聚合，该时间间隔会在整个序列中滑动。结合这些技术，你可以对数据中的趋势做出判断。最后，你了解了识别多变量时间序列中不同变量之间依赖关系的方法。
